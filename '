{-# language StrictData #-}
{-# language GeneralizedNewtypeDeriving, DerivingStrategies #-}

module GhcCompileStats where

import Prelude

import qualified Data.Text as Text
import Control.Monad.Reader
import Data.Set (Set)
import qualified Data.Set as Set
import Conduit
import Chronos
import GHC.Clock (getMonotonicTimeNSec)
import Data.IORef

data GhcCompileStats = GhcCompileStats
    { gcsFirstModule :: String
    , gcsModulesCompiled :: Int
    , gcsModulesSkipped :: Int
    , gcsTotalModules :: Int
    , gcsTemplateHaskellModules :: Int
    , gcsModuleTimes :: Set ModuleTime
    }

data ModuleTime = ModuleTime
    { moduleTime :: Time
    , moduleNumber :: Int
    , moduleName :: String
    }
    deriving (Eq, Ord)

data GhcStatsEnv = GhcStatsEnv
    { gseModules :: Set ModuleTime
    , gseMinimumModule :: Min Int
    , gseMaximumModule :: Max Int
    }

instance Semigroup GhcStatsEnv where
    g0 <> g1 =
        GhcStatsEnv
            { gseModules =
                gseModules g0 <> gseModules g1
            , gseMinimumModule =
                gseMinimumModule g0 <> gseMinimumModule g1
            , gseMaximumModule =
                gseMaximumModule g0 <> gseMaximumModule g1
            }

instance Monoid GhcStatsEnv where
    mempty =
        GhcStatsEnv
            { gseModules =
                mempty
            , gseMinimumModule =
                mempty
            , gseMaximumModule =
                mempty
            }

newGhcStatsEnv :: IO (IORef GhcStatsEnv)
newGhcStatsEnv = do
    newIORef mempty

newtype ModuleStatsM a = ModuleStatsM
    { unModuleStatsM :: ReaderT (IORef GhcStatsEnv) IO a
    }
    deriving newtype
        (Functor, Applicative, Monad, MonadIO, MonadReader GhcStatsEnv, MonadUnliftIO, MonadThrow)

tell :: GhcStatsEnv -> ModuleStatsM ()
tell gse = do
    atomicModifyIORef' (\a -> (a <> gse, ()))

type ModuleStream i o r = ConduitT i o ModuleStatsM r

-- | An extremely dumb program. Pipe the output of a @cabal build@ to this
-- function, and it'll record the time of each line, record how many
-- modules were skipped, etc.
--
-- If you care about how long individual modules take to compile, disable
-- parallelism. Otherwise modules will appear on the list as they are
-- started, but the next module will not necessarily appear when the prior
-- one has completed.
ghcCompileStatsMain :: IO ()
ghcCompileStatsMain = do
    ghcStatsEnv <-
        newGhcStatsEnv
    runConduit $ transPipe (\a -> runReaderT (unModuleStatsM a) ghcStatsEnv)
        $ stdinC
        .| linesUnboundedAsciiC
        .| decodeUtf8C
        .| mapC Text.unpack
        .| mapM_C parseLine

parseLine :: String -> ModuleStatsM ()
parseLine initialLine = do
    liftIO $ putStrLn initialLine
    case initialLine of
        '[' : rest -> do
            case reads rest of
                (currentModuleNumber, ('/' : rest') : _ -> do

                    

                _ ->
                    liftIO $ putStrLn $ mconcat
                        [ "Failed to parse line: "
                        , initialLine
                        ]

        _ ->
            pure ()

